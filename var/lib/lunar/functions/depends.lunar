#!/bin/bash
#                                                          #
# This code is written for Lunar Linux, see                #
# http://www.lunar-linux.org                               #
#                                                          #
############################################################
#                                                          #
# $FUNCTIONS/depends                                       #
# includes find_depends is_depends in_depends              #
# remove_depends add_depends run_depends                   #
# satisfy_depends                                          #
#                                                          #
# 20020710                                                 #
#                                                          #
############################################################
#                                                          #
# Copyrighted Kagan Kongar 2002 under GPLv2                #
#                                                          #
############################################################
#                                                          #
# Merged in more depends routines - sofar - 20030305       # 
#                                                          #
############################################################


# function : find_depends 
# usage    : find_depends "module name"
# purpose  : recursive dependency finder, no need to be installed
function find_depends() {
  debug_msg "function find_depends ($@)"

  # as always, use private depends() and optional_depends() functions
  depends () {
  debug_msg "  depends  ($@)"
    if ! $(echo $FOUND_DEPENDS | grep -qw $1) ; then
      export FOUND_DEPENDS="$FOUND_DEPENDS $1"
      find_depends $1
      echo $1
    fi
  }

  optional_depends() {
  debug_msg "  optional_depends ($@)"
    if ! $(echo $FOUND_DEPENDS | grep -qw $1) ; then
      if module_installed $1 ; then
        export FOUND_DEPENDS="$FOUND_DEPENDS $1"
        find_depends $1
        echo $1
      fi
    fi
  }
  
  export FOUND_DEPENDS="$FOUND_DEPENDS $1"
  if ! run_details $1 &> /dev/null ; then
    exit 1
  fi

  if [ -e "$MODULE_CONFIG" ] ; then
    . "$MODULE_CONFIG"
  fi

  run_module_file $MODULE DEPENDS

}


# function : sort_by_dependency
# usage    : LIST=$(sort_by_dependency $LIST)
# purpose  : return a LIST sorted by dependency
sort_by_dependency() {
 (
  debug_msg "sort_by_dependency ($@)"
  MODULES=$@
  for MODULE in $MODULES ; do
    grep ^$MODULE: $DEPENDS_STATUS | grep ":on:" | awk -F: '{print $1,$2}'
  done | tsort | tac
 )
}


is_depends()  {
  debug_msg "is_depends ($@)"
  # Is $1 a previously selected dependency of any module.
  return $(cat $DEPENDS_STATUS | cut -d: -f2- | grep -q "^$1:on:")
}
                                                                                
                                                                                
in_depends()  {
  debug_msg "in_depends ($@)"
  # Was $2 presented as a depenency for module $1
  return $(grep -q "^$1:$2:" $DEPENDS_STATUS)
}
                                                                                
                                                                                
remove_depends() {
  debug_msg "remove_depends ($@)"
  lock_file $DEPENDS_STATUS_BACKUP &&
  lock_file $DEPENDS_STATUS        ||
  return 1
                                                                                
  if [ -n "$2" ] ; then
    if grep -q "^$1:$2:" $DEPENDS_STATUS ; then
      grep -v "^$1:$2:" $DEPENDS_STATUS_BACKUP > $DEPENDS_STATUS
      verbose_msg "removing depends for \"$1\" on \"$2\""
    fi
  elif grep -q "^$1:" $DEPENDS_STATUS ; then
    grep -v "^$1:" $DEPENDS_STATUS_BACKUP | \
    grep -v ":$1:on:optional:" > $DEPENDS_STATUS
    verbose_msg "removing all depends for and optional on \"$1\""
  fi

  cp $DEPENDS_STATUS $DEPENDS_STATUS_BACKUP
                                                                                
  unlock_file $DEPENDS_STATUS_BACKUP &&
  unlock_file $DEPENDS_STATUS
}
                                                                                

add_depends() {
  debug_msg "add_depends ($@)"
  if ! grep -q "^$1:$2:$3:$4:$5:$6$" $DEPENDS_STATUS ; then
	  if grep -q "^$1:$2:" $DEPENDS_STATUS ; then
		  remove_depends "$1" "$2"
		fi
                                                                                
    verbose_msg "adding \"$4\" depends for \"$1\" on \"$2\" ($3)"
                                                                                
    lock_file $DEPENDS_STATUS_BACKUP                       &&
    lock_file $DEPENDS_STATUS                              &&
    echo  "$1:$2:$3:$4:$5:$6"  >>  $DEPENDS_STATUS         &&
    cat  $DEPENDS_STATUS        >  $DEPENDS_STATUS_BACKUP  &&
    unlock_file $DEPENDS_STATUS_BACKUP                     &&
    unlock_file $DEPENDS_STATUS
  fi
}
                                                                                
     
run_depends() {
  debug_msg "run_depends ($@)"
  # local definitions of depends and optional_depends!
  depends()  {
  debug_msg "  depends ($@)"
    grep -q "^"$1"\$" $TEMP_PREPAREDDEPS 2>/dev/null && return 0

    if ! module_installed $1 && ! module_held $1 ; then
      if ! is_depends $1 && module_exiled $1 ; then
        message "${MODULE_COLOR}${MODULE}:${PROBLEM_COLOR} ! Error: required dependency ${MODULE_COLOR}${1}${DEFAULT_COLOR}${PROBLEM_COLOR} is exiled and cannot be installed${DEFAULT_COLOR}"
        return 1
      else
        message "${MODULE_COLOR}${MODULE}: ${DEFAULT_COLOR}" \
                "Adding required dependency${FILE_COLOR}"   \
                "$1 ${DEFAULT_COLOR}"
        lin --deps $1
        echo "$1" >> $TEMP_PREPAREDDEPS
      fi
    fi
    add_depends "$MODULE" "$1" "on" "required" "$2" "$3"
  }
                                                                                
  optional_depends()  {
  debug_msg "  optional_depends ($@)"
    # parameters:  $1 = module name
    #              $2 = configure parameter if module wanted
    #              $3 = configure parameter if module declined
    #              $4 = description of why to use this module.
                                                                                
    if ! in_depends "$MODULE" "$1" ; then
                                                                               
      if module_exiled $1 ; then
        verbose_msg "\"$MODULE\" optionally depends on exiled module \"$1\""
        add_depends "$MODULE" "$1" "off" "optional" "$2" "$3"
      else
        if module_installed $1 ; then
          DEFAULT="y"
	else
          DEFAULT="n"
        fi

	if module_installed $1 ; then
	  DEPMOD_AVAIL="Use optional ${MESSAGE_COLOR}(presently installed) module${QUERY_COLOR} $1"
	else
	  DEPMOD_AVAIL="Install & use optional ${PROBLEM_COLOR}(not yet installed) ${MESSAGE_COLOR}module${QUERY_COLOR} $1"
	fi
	if query  "$DEPMOD_AVAIL 
        dependency - purpose: $4? " $DEFAULT ; then
          lin  --deps  $1
          add_depends  "$MODULE"  "$1"  "on"   "optional"  "$2"  "$3"
        else
	  add_depends  "$MODULE"  "$1"  "off"  "optional"  "$2"  "$3"
	fi
      fi
    fi
  }
                                                                                
  prepare_depends_status
  grep -q "^"$MODULE"\$" $TEMP_PREPAREDDEPS 2>/dev/null && return 0
  if [ -s "$SCRIPT_DIRECTORY/DEPENDS" ] ; then
    message  "${CHECK_COLOR}Checking dependencies for"  \
             "${MODULE_COLOR}${MODULE}"                   \
             "${DEFAULT_COLOR}"
    run_module_file $MODULE DEPENDS
  fi
}


# function : satisfy_depends
# usage    : satisfy_depends (operates on $MODULE variable)
# purpose  : re-check module deps based on DEPENDS_CONFIG and DEPENDS_STATUS
# NOTE: this is where a missing dependency gets installed! IOW we really do
# "satisfy" any dependencies here!
satisfy_depends()  {
  debug_msg "satisfy_depends ($@)"
  if [ -n "$DEPS_ONLY" ] ; then 
    return 0
  fi
  
  unset OPTS

  if [ -s "$MODULE_CONFIG" ] ; then
    . $MODULE_CONFIG
  fi

  TMP_FILE=$(temp_create "${MODULE}.satify-depends")
  grep "^$MODULE:" $DEPENDS_STATUS > $TMP_FILE

  while read LINE; do
    DEP_MODULE=$(echo $LINE | cut -d: -f2)
    DEP_STATUS=$(echo $LINE | cut -d: -f3)
        DEP_ON=$(echo $LINE | cut -d: -f5)
       DEP_OFF=$(echo $LINE | cut -d: -f6)
                                                                                
    if [ -n "$FIX" ] ; then
      if DEP_STATUS="on" ; then
        lin $FIX $DEP_MODULE
      fi
    elif [ "$DEP_STATUS" == "off" ] || module_exiled $DEP_MODULE ; then
      OPTS="$OPTS $DEP_OFF"
    elif [ "$DEP_STATUS" == "on" ] && ! module_installed $DEP_MODULE && \
        ! module_held $DEP_MODULE ; then
      if lin $SILENT $COMPILE $DEP_MODULE ; then
        OPTS="$OPTS $DEP_ON"
      else
        exit 1
      fi
    else
      OPTS="$OPTS $DEP_ON"
    fi
  done < $TMP_FILE
                                                     
  temp_destroy $TMP_FILE
}


# conflicts... remove conflicting modules
conflicts() {
  debug_msg "conflicts ($@)"
  if module_installed $1 ; then
    lrm $1
  fi

  true
} 


run_conflicts() {
  debug_msg "run_conflicts ($@)"
  run_module_file $MODULE CONFLICTS
}


# create the dependency files if they do not exist
prepare_depends_status()  {
  debug_msg "prepare_depends_status ($@)"
  [ -f $DEPENDS_STATUS ]        || touch  $DEPENDS_STATUS
  [ -f $DEPENDS_STATUS_BACKUP ] || touch  $DEPENDS_STATUS_BACKUP
}


build_module_depends() {
(
  debug_msg "build_module_depends ($@)"
  if [ -n "$DEPS_ONLY" ] ; then
    run_details $1 &&
    run_depends
  else
    run_details $1 &&
    run_configure &&
    run_depends &&
    satisfy_depends
  fi
)
}


build_depends()  {
  debug_msg "build_depends ($@)"
  for MODULE in $@ ; do
    if ! module_installed $MODULE || [ ! -n "$PROBE" ] ; then
      if ! module_held $MODULE ; then
        build_module_depends $MODULE
      else
        verbose_msg "Skipping dependency checking of held module \"$MODULE\""
      fi
    fi
  done
}



