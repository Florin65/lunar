#!/bin/bash
############################################################
#                                                          #
# This code is written for Lunar Linux, see                #
# http://lunar-linux.org                                   #
#                                                          #
############################################################
#                                                          #
# $FUNCTIONS/sources                                       #
# includes sources, md5_verify_source, verify_sources      #
# verify_source                                            #
#                                                          #
# 20020604                                                 #
#                                                          #
############################################################
#                                                          #
# Copyrighted Kagan Kongar 2002 under GPLv2                #
#                                                          #
############################################################


verify_source() {
  debug_msg "verify_source ($@)"
  VERIFIED="true"
  for SOURCE_FILE in $@ ; do
    if ! guess_filename $SOURCE_CACHE/$1 >/dev/null ; then
      message "${PROBLEM_COLOR}Missing ${FILE_COLOR}${1}${DEFAULT_COLOR}"
      message "${PROBLEM_COLOR}Lunar Install aborting.${DEFAULT_COLOR}"
      activity_log "lin" "$MODULE" "$VERSION" "failed" "because it was missing source:  $1"
      return 1
    fi
  done
}


# function : sources
# usage    : sources <module_name> {MD5|VFY|
# purpose  : displays the filenames and md5sums or VFY part of sources
#            for a given module
sources() {
(
  debug_msg "sources ($@)"
  MAX_SOURCES=${MAX_SOURCES:=100}

  if ! run_details $1 ; then
    return 1
  fi

  for (( CNT=0; CNT<=$MAX_SOURCES; CNT++ )) ; do
    TEMP=SOURCE$((CNT))
    TEMP=${TEMP/SOURCE0/SOURCE}

    eval SRC1=\$${TEMP}
    if [ "$2" == "MD5" ] ; then
      eval SRC_MD5=\$${TEMP}_MD5
      if [ -z "$SRC_MD5" ] ; then
        SRC_MD5=0
      fi
    fi

    eval SRC2=\$SOURCE$((CNT+1))
    eval SRC3=\$SOURCE$((CNT+2))

    if [ -n "$SRC1" ] ; then
      echo $SRC1
      if [ "$2" == "MD5" ] ; then
        echo $SRC_MD5
      fi
    fi

    #if two consequtive empty sources, then break
    [ -z "$SRC2" ] && [ -z "$SRC3" ] && {
      break
    }
  done
)
}


# function : md5_verify_source
# usage    : md5_verify_source filename md5
# purpose  : md5 verifies a filename
md5_verify_source() {
  debug_msg "md5_verify_source ($@)"
  TMP_MD5=$(md5sum $SOURCE_CACHE/$1 | cut -d " " -f 1-1)
  if [ "$2" != "$TMP_MD5" ] ; then
    verbose_msg "offending md5sum: $TMP_MD5"
    verbose_msg "should be md5sum: $2"
    return 1
  fi
}


# function : sha1_verify_source
# usage    : sha1_verify_source filename sha1
# purpose  : sha1 verifies a filename
sha1_verify_source() {
  debug_msg "sha1_verify_source ($@)"
  TMP_SHA1=$(sha1sum $SOURCE_CACHE/$1 | cut -d " " -f 1-1)
  if [ "$2" != "$TMP_SHA1" ] ; then
    verbose_msg "offending sha1sum: $TMP_SHA1"
    verbose_msg "should be sha1sum: $2"
    return 1
  fi
}


erase()  {
  debug_msg "erase ($@)"
  if [ "$PARTIAL" == "off" ]; then
    verbose_msg "erase: deleting \"$(guess_filename $1)\""
    rm -f $(guess_filename $1)
  fi
}


unpack() {
  debug_msg "unpack ($@)"

  FILENAME=$(guess_filename $SOURCE_CACHE/$1)
  verbose_msg "Unpacking \"$FILENAME\" in \"$(pwd)\""

  case $(file -b $FILENAME | cut -d' ' -f1) in
        bzip2)  tar jxf $FILENAME -o --no-same-permissions ;;
         gzip)  tar zxf $FILENAME -o --no-same-permissions ;;
    compress*)  tar zxf $FILENAME -o --no-same-permissions ;;
	  tar)  tar xf $FILENAME -o --no-same-permissions ;;
          Zip)  unzip -q $FILENAME ;;
          RPM)  rpmunpack  < $FILENAME  |  gzip  -d     \
                                        |  cpio  -idm   ;;
            *)  false                                   ;;
  esac

  if [ "$?" != 0 ] ; then
    message "${PROBLEM_COLOR}! Error while unpacking ${FILE_COLOR}$SOURCE_CACHE/$1${DEFAULT_COLOR}${PROBLEM_COLOR}${DEFAULT_COLOR}"
    return 1
  fi

  # I don't get this :
  [ -n "$SOURCE_DIRECTORY" ] &&
  [ -d "$SOURCE_DIRECTORY" ]
  
  # someone care to document this ???
  if [[ $(echo $CFLAGS | grep fbranch-probabilities) ]]; then
    chown -R 777 $SOURCE_DIRECTORY 2>&1 >/dev/null
  else
    chown -R root:root $SOURCE_DIRECTORY 2>&1 >/dev/null 
  fi
}


# usage : gpg_verify_src $SRC $GPG-SIG-URL $GPG-PUBLIC-KEYS-URL
gpg_verify_source() {
  debug_msg "gpg_verify_source($@)"
  if [ ! -x /usr/bin/gpg ] ; then
    message "${PROBLEM_COLOR}! Cannot verify sources without ${MODULE_COLOR}gpg${DEFAULT_COLOR}${PROBLEM_COLOR} installed${DEFAULT_COLOR}"
    return 1
  fi

  # do we need to download a keyset?
  if [ -n "$3" ] ; then
    TMP_GPG_KEYS=$(temp_create "gpg-pubkeys")
    verbose_msg "Downloading pub keys from \"$3\""
    # TODO calling wget is a hack... we should accept file: urls too
    if wget $3 -O $TMP_GPG_KEYS -q ; then
      GNUPGHOME=/var/state/lunar/ gpg --import $TMP_GPG_KEYS
    fi
  fi
  
  # try to get the required key
  TMP_GPG_SIG=$(temp_create "gpg-signature")
  verbose_msg "Downloading signature \"$2\""
  # TODO calling wget is a hack... we should accept file: urls too
  if wget $2 -O $TMP_GPG_SIG -q ; then
    verbose_msg "Verifying signature of \"$SOURCE_CACHE/$1\""
    verbose_msg "GNUPGHOME=/var/state/lunar/ gpg --verify $TMP_GPG_SIG $SOURCE_CACHE/$1"
    if ! GNUPGHOME=/var/state/lunar/ gpg --verify $TMP_GPG_SIG $SOURCE_CACHE/$1 ; then
      verbose_msg "gpg exited with \"$?\""
      temp_destroy $TMP_GPG_SIG
      temp_destroy $TMP_GPG_KEYS
      return 1
    fi
    temp_destroy $TMP_GPG_SIG
    temp_destroy $TMP_GPG_KEYS
  else
    message "cannot download key!"
    temp_destroy $TMP_GPG_SIG
    temp_destroy $TMP_GPG_KEYS
    return 1
  fi

}


# usage: verify_all_sources $MODULE
# check all sources regarding verification method
verify_all_sources() {
(
  debug_msg "verify_all_sources ($@)"
  MAX_SOURCES=${MAX_SOURCES:=100}

  if ! run_details $1 ; then
    return 1
  fi

  if [ -n "$WANT_VERSION" ] ; then
    message "${PROBLEM_COLOR}WARNING:${DEFAULT_COLOR}${MESSAGE_COLOR} Integrity checking is disabled when using \"--want\"!${DEFAULT_COLOR}"
    return 0
  fi

  for (( C=0 ; C<=$MAX_SOURCES ; C++ )) ; do
    TEMP=SOURCE$((C))
    TEMP=${TEMP/SOURCE0/SOURCE}
    eval SRC1=\$${TEMP}
   
    # it needs to exist prior before we can check it:
    if ! verify_source $SRC1 ; then
      return 1
    fi

    eval VFYS=\${${TEMP}_VFY[@]}

    # cumulate result:
    unset RESULT
    if [ -n "$VFYS" ] ; then
      # we need to check ALL args for validity... if one fails we should not
      # trust the source
      for VFY in $VFYS ; do
        if [ "${VFY:0:4}" == "md5:" ] ; then
	  if ! md5_verify_source $SRC1 $(echo $VFY | cut -d: -f2) ; then
	    message "${PROBLEM_COLOR}! md5sum check failed for ${DEFAULT_COLOR}${FILE_COLOR}$SRC1${DEFAULT_COLOR}"
	    RESULT=1
	  fi
	elif [ "${VFY:0:5}" == "sha1:" ] ; then
	  if ! sha1_verify_source $SRC1 $(echo $VFY | cut -d: -f2) ; then
	    message "${PROBLEM_COLOR}! sha1sum check failed for ${DEFAULT_COLOR}${FILE_COLOR}$SRC1${DEFAULT_COLOR}"
	    RESULT=1
	  fi
	elif [ "${VFY:0:4}" == "gpg:" ] ; then
	  if ! gpg_verify_source $SRC1 $(echo $VFY | cut -d: -f2- | cut -f1) $(echo $VFY | cut d: -f2- | cut -f2) $(echo $VFY | cut -d: -f2- | cut -f3) ; then
	    message "${PROBLEM_COLOR}! gpg signature check failed for ${DEFAULT_COLOR}${FILE_COLOR}$SRC1${DEFAULT_COLOR}"
	    RESULT=1
	  fi
        fi
      # so what if?
      if [ "$RESULT" == "1" ] ; then
        # remove?
	MODULE=$1
	message "${MESSAGE_COLOR}You should remove ${DEFAULT_COLOR}${FILE_COLOR}$SRC1${DEFAULT_COLOR}${MESSAGE_COLOR} !${DEFAULT_COLOR}"
	
	if query "Remove \"$SOURCE_CACHE/$SRC1\" ? " y ; then
          rm -f $SOURCE_CACHE/$SRC1
	fi
      fi
      done
    fi

    # our fallthrough as usual:
    eval SRC2=\$SOURCE$((C+1));
    eval SRC3=\$SOURCE$((C+2));
    [ -z "$SRC2" ] && [ -z "$SRC3" ] && break
  done    
 
  # result?
  if [ -n "$RESULT" ] ; then
    return 1
  fi

  # if we removed something we better make sure we break:
  if ! verify_source $(sources $1) ; then
    return 1
  fi
)
}


rm_source_dir() {
  debug_msg "rm_source_dir ($@)"

  if [ "$KEEP_SOURCE" == "on" ] ; then
    return 0
  fi

  cd $BUILD_DIRECTORY
  DEAD_DIR=$1
  DEAD_DIR=${DEAD_DIR:=$SOURCE_DIRECTORY}

  verbose_msg "destroying building dir \"$DEAD_DIR\""
  if [ "$TMPFS" != "off" ] ; then
    umount $DEAD_DIR 2> /dev/null
    rmdir $DEAD_DIR 2> /dev/null
  else
    rm -rf $DEAD_DIR 2> /dev/null
  fi

  rm -f $BOOST_LOCK
}


mk_source_dir() {
  debug_msg "mk_source_dir ($@)"

  cd $BUILD_DIRECTORY
  NEW_DIR=$1
  NEW_DIR=${NEW_DIR:=$SOURCE_DIRECTORY}

  verbose_msg "creating building dir \"$NEW_DIR\""
  if [ "$TMPFS" != "off" ] ; then 
    if [ -d "$NEW_DIR" ] ; then
      verbose_msg "Removing old source directory first!"
      umount $NEW_DIR 2>/dev/null
      rmdir $NEW_DIR 2>/dev/null
    fi
    mkdir -p $NEW_DIR &&
    mount -o size=1g,nr_inodes=1m -t tmpfs tmpfs $NEW_DIR
  else
    if [ -d $NEW_DIR ] ; then
      verbose_msg "Removing old source directory first!"
      rm -rf $NEW_DIR 2>/dev/null
    fi
    mkdir -p $NEW_DIR
  fi
}


validate_source_dir()  {
  debug_msg "validate_source_dir ($@)"

  verbose_msg "validating \"$SOURCE_DIRECTORY\""
  if  [  -n    "$SOURCE_DIRECTORY"                                   ]  &&
      [        "$SOURCE_DIRECTORY"  !=           "$BUILD_DIRECTORY"  ]  &&
      echo     "$SOURCE_DIRECTORY"  |  grep  -q  "$BUILD_DIRECTORY"
  then
    true
  else
    message  "\$SOURCE_DIRECTORY and \$BUILD_DIRECTORY must not be the same."
    message  "\$SOURCE_DIRECTORY must not be empty."
    message  "\$SOURCE_DIRECTORY must be a subdirectory of \$BUILD_DIRECTORY"
    false
  fi
}


