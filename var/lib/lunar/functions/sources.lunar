#                                                          #
# This code is written for Lunar Linux, see                #
# http://www.lunar-linux.org                               #
#                                                          #
############################################################
#                                                          #
# $FUNCTIONS/sources                                       #
# includes sources, md5_verify_source, verify_sources      #
# verify_source                                            #
#                                                          #
# 20020604                                                 #
#                                                          #
############################################################
#                                                          #
# Copyrighted Kagan Kongar 2002 under GPLv2                #
#                                                          #
############################################################


verify_source() {
  debug_msg "verify_source ($@)"
  VERIFIED="true"
  for SOURCE_FILE in $@ ; do
    if ! guess_filename $SOURCE_CACHE/$1 >/dev/null ; then
      message "${PROBLEM_COLOR}Missing ${FILE_COLOR}${1}${DEFAULT_COLOR}"
      message "${PROBLEM_COLOR}Lunar Install aborting.${DEFAULT_COLOR}"
      activity_log "lin" "$MODULE" "$VERSION" "failed" "because it was missing source:  $1"
      return 1
    fi
  done
}


verify_sources() {
  debug_msg "verify_sources ($@)"
  md5_verify_source $(sources $MODULE MD5)
}


# function : sources
# usage    : sources <module_name> {MD5|VFY|
# purpose  : displays the filenames and md5sums or VFY part of sources
#            for a given module
sources() { (
  debug_msg "sources ($@)"
  MAX_SOURCES=${MAX_SOURCES:=100}

  if ! run_details $1 ; then
    return 1
  fi

  for (( CNT=0; CNT<=$MAX_SOURCES; CNT++ )) ; do
    TEMP=SOURCE$((CNT))
    TEMP=${TEMP/SOURCE0/SOURCE}

    eval SRC1=\$${TEMP}
    if [ "$2" == "MD5" ] ; then
      eval SRC_MD5=\$${TEMP}_MD5
      if [ -z "$SRC_MD5" ] ; then
        SRC_MD5=0
      fi
    elif [ "$2" == "VFY" ] ; then
      eval SRC_VFY=\$${TEMP}_VFY
      if [ -z "$SRC_VFY" ] ; then
        SRC_VFY=0
      fi
    fi

    eval SRC2=\$SOURCE$((CNT+1))
    eval SRC3=\$SOURCE$((CNT+2))

    if [ -n "$SRC1" ] ; then
      echo $SRC1
      if [ "$2" == "MD5" ] ; then
        echo $SRC_MD5
      elif [ "$2" == "VFY" ] ; then
        echo $SRC_VFY
      fi
    fi

    #if two consequtive empty sources, then break
    [ -z "$SRC2" ] && [ -z "$SRC3" ] && {
      break
    }
  done
) }


# function : md5_verify_source
# usage    : md5_verify_source filename_1 md5_1, filename_2 md52.....
# purpose  : md5 verifies a filename
md5_verify_source() {
  debug_msg "md5_verify_source ($@)"
  ALL_OK=true   
  while [ -n "$2" ]
  do
    if ! verify_source $1 ; then
      return 1
    fi

    if [ "$2" == "0" ] ; then
      TEMP=0
    else
      verbose_msg "checking md5sum of \"$1\""
      TEMP=$(md5sum $SOURCE_CACHE/$1 | cut -d " " -f 1-1)
    fi
      
    if [ "$TEMP" != "$2" ] ; then 
       message  "${PROBLEM_COLOR}! Wrong md5 sum for ${FILE_COLOR}${1}${DEFAULT_COLOR}"
       message  "${PROBLEM_COLOR}Removing ${FILE_COLOR}${SOURCE_CACHE}/${1}${DEFAULT_COLOR}"
       rm -f $SOURCE_CACHE/$1 2>/dev/null                             &&
       message  "${FILE_COLOR}Removed${DEFAULT_COLOR}"              ||
       message  "${PROBLEM_COLOR}Unable to remove${DEFAULT_COLOR}" 
       ALL_OK=false
    fi

    shift 2
  done
  $ALL_OK
}


unpack() {
  debug_msg "unpack ($@)"

    FILENAME=$(guess_filename $SOURCE_CACHE/$1)

  verbose_msg "Unpacking \"$FILENAME\" in \"$(pwd)\""

  case $(file -b $FILENAME | cut -d' ' -f1) in
        bzip2)  tar jxf $FILENAME ;;
         gzip)  tar zxf $FILENAME ;;
	  tar)  tar xf $FILENAME ;;
    compress*)  tar zxf $FILENAME ;;
          Zip)  unzip -q $FILENAME ;;
          RPM)  rpmunpack  < $FILENAME  |  gzip  -d     \
                                        |  cpio  -idm   ;;
            *)  false                                   ;;
  esac

  if [ $? != 0 ] ; then
    message "${PROBLEM_COLOR}! Error while unpacking ${FILE_COLOR}$SOURCE_CACHE/$1${DEFAULT_COLOR}${PROBLEM_COLOR}${DEFAULT_COLOR}"
    return 1
  fi
  
  [ -n "$SOURCE_DIRECTORY" ] &&
  [ -d "$SOURCE_DIRECTORY" ]
  
  if [[ $(echo $CFLAGS | grep fbranch-probabilities) ]]; then
    chown -R 777 $SOURCE_DIRECTORY 2>&1 >/dev/null
  else
    chown -R root:root $SOURCE_DIRECTORY 2>&1 >/dev/null 
  fi
}



# usage : gpg_verify_src $SRC $GPG-SIG-URL $GPG-PUBLIC-KEYS-URL
gpg_verify_source() {
  if [ ! -x /usr/bin/gpg ] ; then
    message "${PROBLEM_COLOR}! Cannot verify sources without ${MODULE_COLOR}gpg${DEFAULT_COLOR}${PROBLEM_COLOR} installed${DEFAULT_COLOR}"
    return 1
  fi

  # do we need to download a keyset?
  if [ -n "$3" ] ; then
    TMP_GPG_KEYS=$(temp_create "gpg-pubkeys")
    verbose_msg "Downloading pub keys from \"$3\""
    if wget $3 -O $TMP_GPG_KEYS -q ; then
      GNUPGHOME=/var/state/lunar/ gpg --import $TMP_GPG_KEYS
    fi
  fi
  
  # try to get the required key
  TMP_GPG_SIG=$(temp_create "gpg-signature")
  verbose_msg "Downloading signature \"$2\""
  if wget $2 -O $TMP_GPG_SIG -q ; then
    verbose_msg "Verifying signature of \"$1\""
    verbose_msg "GNUPGHOME=/var/state/lunar/ gpg --verify $TMP_GPG_SIG $1"
    if GNUPGHOME=/var/state/lunar/ gpg --verify $TMP_GPG_SIG $1 ; then
      echo good!
    else
      echo bad!
    fi
#    temp_destroy $TMP_SIG
    verbose_msg "result was \"$?\""
  else
    message "B()RK"
    temp_destroy $TMP_SIG
    exit 1
  fi

}


