#!/bin/bash
#                                                          #
# This code is written for Lunar Linux, see                #
# http://www.lunar-linux.org                               #
#                                                          #
############################################################
#                                                          #
# $FUNCTIONS/main.lunar                                    #
# contains all main handling code, aka the long complex    #
# functions like renew, update, fix, etc. One day they all #
# will be in here.                                         #
#                                                          #
############################################################
#                                                          #
# Copyrighted Auke Kok 2003 under GPLv2                    #
#                                                          #
############################################################

# function : renew
# usage    : renew
# purpose  : frontend function that includes all renewing code
renew() {
  debug_msg "renew ($@)"
  message "${MESSAGE_COLOR}Starting update of installed modules${DEFAULT_COLOR}"

  purge_modules
  
  export TMP_LIN_SUCCESS=$(temp_create "successfull")
  export TMP_LIN_FAIL=$(temp_create "failed")
      
  update_modules

  if [ "$AUTOFIX" == "on" ] ; then
    message "${MESSAGE_COLOR}Executing AUTOFIX : lunar fix${DEFAULT_COLOR}"
    run_fix
  fi

  if [ "$AUTOPRUNE" == "on" ] ; then
    message "${MESSAGE_COLOR}Executing AUTOPRUNE : lunar prune${DEFAULT_COLOR}"
    prune
  fi

  display_update_log

  temp_destroy $TMP_LIN_SUCCESS
  temp_destroy $TMP_LIN_FAIL

}


update() {
  debug_msg "update ($@)"
  if  ps  -C  lin  >  /dev/null;  then
    echo    "Unable to update lunar concurrently while installing."
    sleep   5
    return  1
  fi

  if lin moonbase ; then
    if (( $(lvu installed $LUNAR_MODULE) < $(lvu version $LUNAR_MODULE) )) 
    then
      lin $LUNAR_MODULE && lunar renew
    else
      lunar renew
    fi
  fi

}


rebuild()  {
  debug_msg "rebuild ($@)"

  message  "${MESSAGE_COLOR}Startings non-recursive rebuild${DEFAULT_COLOR}"
  message  "${MESSAGE_COLOR}Running FIX on all modules${DEFAULT_COLOR}"
  echo run_fix

  LIST=$(grep ":installed:" $MODULE_STATUS | cut -d: -f1)

  message "${MESSAGE_COLOR}Sorting modules by dependency${DEFAULT_COLOR}"
  QUEUE=$(sort_by_dependency $LIST)

  TMP_QUEUE=$(temp_create "rebuild-queue")
  for MODULE in $QUEUE ; do
    echo $MODULE >> $TMP_QUEUE
  done

  unset MODULE
  if query  "Edit rebuild queue?" n ; then
    edit_file $TMP_QUEUE
  fi

  QUEUE=$(cat $TMP_QUEUE)
  temp_destroy $TMP_QUEUE

  if [ -n "$QUEUE" ] ; then
    message "${MESSAGE_COLOR}Starting rebuild of modules${DEFAULT_COLOR}"
    lin -c $QUEUE
  fi

}


resurrect()  {
(
  debug_msg "resurrect ($@)"

  if [ -s /etc/lunar/local/optimizations ] ; then
    . /etc/lunar/local/optimizations
  fi
  if ! run_details $1 ; then
    return 1
  fi
  run_conflicts    &&
  satisfy_depends  &&

  STATUS=installed &&

  if module_held $MODULE ; then
    VERSION=$(installed_version $MODULE)
    STATUS=held
    lrm --keepconfig $MODULE
  elif module_installed $MODULE ; then
    lrm --keepconfig $MODULE
  fi &&

  CACHE_BZ="$INSTALL_CACHE/$MODULE-$VERSION-$BUILD.tar.bz2"

  if [ -f "$CACHE_BZ" ] && bzip2 -tf $CACHE_BZ ; then
    message  "${RESURRECT_COLOR}Resurrecting ${MODULE_COLOR}${MODULE}${DEFAULT_COLOR} ${MESSAGE_COLOR}version ${VERSION_COLOR}${VERSION}${DEFAULT_COLOR}"
    bzip2 -cd $CACHE_BZ | tar -Pkx 1>/dev/null 2>&1
    add_module $MODULE $STATUS $VERSION &&
    verbose_msg "running \"lunar fix $MODULE\"" &&
    if run_fix $MODULE ; then
      report $INSTALL_LOGS/$MODULE-$VERSION "install log" $MODULE $VERSION &&
      sound SUCCESS
      activity_log  "lin"  "$MODULE"  "$VERSION"  "success"  "resurrected"
      message  "${RESURRECT_COLOR}Resurrected ${MODULE_COLOR}${MODULE}${DEFAULT_COLOR} ${MESSAGE_COLOR}succesfully${DEFAULT_COLOR}"
    else
      sound FAILURE
      activity_log  "lin"  "$MODULE"  "$VERSION"  "failed"  "resurrect failed"
      false
    fi
  else
    # do not log an error in case we tried autoresurrect:
    if [ "$AUTORESURRECT" == "off" -o -n "$COMPILE" ] ; then
      sound FAILURE
      activity_log  "lin"  "$MODULE"  "$VERSION"  "failed"  "resurrect failed"
      false
    fi
    false
  fi
)
}

resurrect_modules() {
  debug_msg "resurrect_modules ($@)"
  for MODULE in $@ ; do
    if run_details $MODULE ; then
      resurrect $MODULE
    fi
  done
}


lin_module()  {
(
  debug_msg "lin_module ($@)"
  xterm_msg "lin: Processing $1"
  # make sure we got all the info
  if ! run_details $1 ; then
    return 1
  fi

  # resurrect if we can, but not is -c was issued
  if [ "$AUTORESURRECT" == "on" -a -z "$COMPILE" ] ; then
    # we also do not resurrect if $MODULE is currently installed!
    if ! module_installed $MODULE ; then
      if resurrect $MODULE ; then
        return 0
      fi
    fi
  fi

  # set the installwatchfile
  export INSTALLWATCHFILE=$(temp_create "$MODULE.installwatch")

  # lock the module for installation, check for moonbase call
  mod_v_safe_edit $MODULE 
  linING="/var/lock/installing.$MOD_V_SNAME"
  if [ "$MODULE" == "moonbase" ] ; then
    if ! current_locked && ! solo_locked ; then
      echo $$ > $linING       &&
      lget moonbase           &&
      rm -f $linING           &&
      return
    else
      exit 1
    fi
  fi
  check_blacklist             &&
  
  # here we run CONFLICTS, DEPENDS and CONFIGURE stuff
  run_conflicts               &&
  satisfy_depends             &&
  show_downloading            &&

  # last minute source code presence check:
  (
    for SOURCE in $(sources $MODULE) ; do
      if [ ! -f $SOURCE_CACHE/$SOURCE ] ; then
        lget $MODULE
        break
     fi
    done
  ) &&

  # now entering the physical BUILD stage
  if ! current_locked && ! solo_locked ; then
    echo $$ > $linING  &&
    start_logging  &&
    if [ -z "$BUILD" ] ; then
      optimize
    fi &&

    if ! run_pre_build ; then
      LIN_ERROR="PRE_BUILD"
    else

      # important stuff here!!!
      invoke_installwatch &&
      
      if ! run_build ; then
        LIN_ERROR="BUILD"
      else
        if ! run_post_build ; then
          LIN_ERROR="POST_BUILD"
	fi
      fi
    fi

    devoke_installwatch
    stop_logging
    
    if [ -n "$LIN_ERROR" ] ; then
      if [ -f "$INSTALLWATCHFILE" ] ; then
        temp_destroy $INSTALLWATCHFILE
      fi
      sound FAILURE
      message "${PROBLEM_COLOR}! Problem detected during ${FILE_COLOR}$LIN_ERROR${DEFAULT_COLOR}"
      rm -f $linING
      report $COMPILE_LOGS/$MOD_V_SNAME-$VERSION.bz2 "compile log" $MODULE $VERSION
      activity_log  "lin"  "$MODULE"  "$VERSION"  "failed" "Due to build errors during $LIN_ERROR"
      return 1
    fi  

    if ! boost ; then
      LIN_ERROR="boost"
    else
      if ! run_post_install ; then
        LIN_ERROR="POST_INSTALL"
      fi
    fi
    if [ -f "$INSTALLWATCHFILE" ] ; then
      verbose_msg "removing installwatch file"
      temp_destroy $INSTALLWATCHFILE
    fi

    if [ -n "$LIN_ERROR" ] ; then
      sound FAILURE
      message "${PROBLEM_COLOR}! Problem detected during ${FILE_COLOR}$LIN_ERROR${DEFAULT_COLOR}"
      rm -f $linING
      report $COMPILE_LOGS/$MOD_V_SNAME-$VERSION.bz2 "compile log" $MODULE $VERSION
      activity_log  "lin"  "$MODULE"  "$VERSION"  "failed" "Due to build errors during $LIN_ERROR"
      return 1
    fi

    rm_source_dir               &&
    report $INSTALL_LOGS/$MOD_V_SNAME-$VERSION "install log" $MODULE $VERSION &&
    rm -f $linING               &&
    sound SUCCESS               &&
    activity_log  "lin"  "$MODULE"  "$VERSION"  "success"

    if [ "$?" != 0 ] ; then
      sound FAILURE
      message "${PROBLEM_COLOR}! Problem detected${DEFAULT_COLOR}"
      rm -f $linING
      report $COMPILE_LOGS/$MOD_V_SNAME-$VERSION.bz2 "compile log" $MODULE $VERSION
      activity_log  "lin"  "$MODULE"  "$VERSION"  "failed" "Due to build errors during or after $LIN_ERROR"
      return 1
    fi
  fi
)
}


