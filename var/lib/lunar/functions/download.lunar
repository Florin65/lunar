#!/bin/sh
############################################################
#                                                          #
# download.lunar - get sources from the net                #
#                                                          #
############################################################
# leach is part of the sorcery spell management utility    #
# Copyright 2001 by Kyle Sallee                            #
############################################################
#                                                          #
# this WAS the leach script of a source based Linux distro,#
# calls Sorcerer GNU/Linux, or SGL. SGL is no longer       #
# available with GPL license. Since this script was taken  #
# before licensing scheme change, no legal problems I      #
# guess.                                                   #
#                                                          #
# the code is re-written for Lunar. The previous Copyright #
# notices are kept; just in case some code is left :=)     #
# Kagan Kongar <kongar@tsrsb.org.tr>, 20020519             #
#                                                          #
# This secondly was lget mostly, and has been moved into   #
# a separate lunar functions file handling all the generic #
# downloading functionality for lunar                      #
#                                                          #
############################################################
#                                                          #
# Parts Copyrighted  Jason Johnston  2002 under GPLv2      #
#                                                          #
# Parts Copyrighted  Kagan Kongar  2002 under GPLv2        #
#                                                          #
# Parts Copyrighted  Auke Kok  2002 under GPLv2            #
#                                                          #
############################################################


get_svn() {(
  if ! module_installed subversion ; then
    message "${PROBLEM_COLOR}! Cannot fetch SVN sources without \"subversion\" installed${DEFAULT_COLOR}"
    exit 1
  fi

  SVN_URL=$(echo $1 | cut -d: -f1-2)
  SVN_DIR=$(echo $1 | cut -d: -f3)

  message  "${MESSAGE_COLOR}Downloading SVN module for" \
 	   "module ${MODULE_COLOR}${MODULE}${DEFAULT_COLOR}"

  mk_source_dir /tmp/$MODULE-$VERSION
  cd /tmp/$MODULE-$VERSION

  if [[ -f $SOURCE_CACHE/$2 ]]; then
    verbose_msg "Extracting local SVN copy"
    # unpacking in last component dir of $SVN_DIR
    CD=$(pwd)
    if ! tar xjf $SOURCE_CACHE/$2 ; then
      message "${PROBLEM_COLOR}Warning: bad local SVN copy, checking out fresh SVN copy${DEFAULT_COLOR}"
      
      rm_source_dir /tmp/$MODULE-$VERSION
      mk_source_dir /tmp/$MODULE-$VERSION
    fi
  fi

  NUM_RETRY=${NUM_RETRY:-5}

  # 0 == infinity
  if [ $NUM_RETRY -eq 0 ]; then
      NUM_RETRY=1000
  fi

  for (( TRY=1 ; $TRY<$NUM_RETRY+1 ; TRY++ )) ; do
    if [[ -d ${SVN_DIR}/.svn ]]; then
      cd ${SVN_DIR}
      verbose_msg "[${TRY}] svn up"
      svn up && GOT_SVN="yes" 
      cd ${CD}
    elif ! [[ -d ${SVN_DIR}/.svn ]]; then
      verbose_msg "[${TRY}] svn co $SVN_URL $SVN_DIR"
      svn co $SVN_URL $SVN_DIR && GOT_SVN="yes"
    fi

    if [[ "$?" == "0" ]]; then
      break
    fi

    sleep 2
  done
  
  if [[ "$GOT_SVN" == "yes" ]]; then
    message "${MESSAGE_COLOR}Creating ${FILE_COLOR}${SOURCE}${DEFAULT_COLOR}"
    # pack in last component dir of $CVSMODULE
    tar cjf $SOURCE_CACHE/$2 $SVN_DIR
  else
    activity_log "lget"  "$MODULE"  "$VERSION"  "failed" "Could not get $1"
  fi

  cd /tmp
  rm_source_dir /tmp/$MODULE-$VERSION

)}


get_cvs() {(
  if ! module_installed cvs ; then
    message "${PROBLEM_COLOR}! Cannot fetch CVS sources without \"cvs\" installed!${DEFAULT_COLOR}"
    exit 1
  fi

  [ -f ~/.cvspass ] || touch ~/.cvspass

  CVSURL=$(echo $1 | sed "s:^cvs\://::")
  CVSARGS=$(echo $CVSURL | cut -d@ -f1)
  CVSSERVER=$(echo $CVSURL | cut -d@ -f2 | cut -d: -f1)
  CVSSPATH=$(echo $CVSURL | cut -d@ -f2 | cut -d: -f2)
  CVSMODULE=$(echo $CVSURL | cut -d@ -f2 | cut -d: -f3)
  CVSRELEASE=$(echo $CVSURL | cut -d@ -f2 | cut -d: -f4)
  CVSOPTIONS=$(echo $CVSURL | cut -d@ -f2 | cut -d: -f5)


  if [ ! -z $CVSRELEASE ]; then
    CVSRELEASE="-r $CVSRELEASE"
  fi

  export CVSROOT="$CVSARGS@$CVSSERVER:$CVSSPATH"

  message  "${MESSAGE_COLOR}Downloading CVS module"                      \
           "${FILE_COLOR}${CVSMODULE}${DEFAULT_COLOR}${MESSAGE_COLOR}"   \
 	   "for module ${MODULE_COLOR}${MODULE}${DEFAULT_COLOR}"

  mk_source_dir /tmp/$MODULE-$VERSION
  cd /tmp/$MODULE-$VERSION

  if [[ -f $SOURCE_CACHE/$2 ]]; then
    verbose_msg "Extracting local CVS copy"
    # unpacking in last component dir of $CVSMODULE
    CD=$(pwd)
    mkdir -p $(dirname $CVSMODULE)
    cd $(dirname $CVSMODULE)
    if ! tar xjf $SOURCE_CACHE/$2 ; then
      message "${PROBLEM_COLOR}Warning: bad local CVS copy, checking out fresh CVS copy${DEFAULT_COLOR}"
      
      rm_source_dir /tmp/$MODULE-$VERSION
      mk_source_dir /tmp/$MODULE-$VERSION
    fi
    cd $CD
  fi

  verbose_msg "CVSROOT=\"$CVSROOT\""

  NUM_RETRY=${NUM_RETRY:-5}

  # 0 == infinity
  if [ $NUM_RETRY -eq 0 ]; then
      NUM_RETRY=1000
  fi

  for (( TRY=1 ; $TRY<$NUM_RETRY+1 ; TRY++ )) ; do
    if [[ -d $CVSMODULE/CVS ]]; then
      verbose_msg "[${TRY}] cvs -qz3 up -PAd $CVSOPTIONS $CVSRELEASE"
      cvs -qz3 up -PAd $CVSOPTIONS $CVSRELEASE && GOT_CVS="yes" 
    elif ! [[ -d CVS ]]; then
      verbose_msg "[${TRY}] cvs -qz3 co $CVSOPTIONS $CVSRELEASE $CVSMODULE"
      cvs -qz3 co $CVSOPTIONS $CVSRELEASE $CVSMODULE && GOT_CVS="yes"
    fi

    if [[ "$?" == "0" ]]; then
      break
    fi

    sleep 2
  done
  
  if [[ "$GOT_CVS" == "yes" ]]; then
    message "${MESSAGE_COLOR}Creating ${FILE_COLOR}${2}${DEFAULT_COLOR}"
    # pack in last component dir of $CVSMODULE
    cd $(dirname $CVSMODULE)
    tar cjf $SOURCE_CACHE/$2 $(basename $CVSMODULE)
    cd $CD
  else
    activity_log "lget"  "$MODULE"  "$VERSION"  "failed" "Could not get $CVSMODULE"
  fi

  cd /tmp
  rm_source_dir /tmp/$MODULE-$VERSION

)}


erase()  {
  if [ "$PARTIAL" = "off" ]; then
    verbose_msg "erase: deleting \"$(guess_filename $1)\""
    rm -f $(guess_filename $1)
  fi
}


call_wget()  {  
   [ -n "$http_proxy" ] && export http_proxy=$http_proxy
   [ -n  "$ftp_proxy" ] && export  ftp_proxy=$ftp_proxy
   [ -n   "$no_proxy" ] && export   no_proxy=$no_proxy

   verbose_msg "calling \"wget $CACHE $RATE $FTP_CONNECTION $RETRIES $PARTIAL $1\""
   wget $CACHE $RATE $FTP_CONNECTION $RETRIES $PARTIAL $1
}


fuzzy_wget()  {

  FTP_CONNECTION="--passive-ftp"
  [ "$FTP_ACTIVE"  == "on"   ] || 
  [ "$FTP_PASSIVE" == "off"  ] && 
  unset FTP_CONNECTION 

  PARTIAL="-c"
  [ "$CONTINUE" == "off" ] && unset PARTIAL

  CACHE="--cache=on"
  [ "$USE_CACHE" == "off" ] && CACHE="--cache=off"

  NUM_RETRY=${NUM_RETRY:=5}
  RETRIES="--tries=${NUM_RETRY}"

  [  -n  "$DOWNLOAD_RATE"  ] && RATE="--limit-rate=${DOWNLOAD_RATE}"

  FUZZY=${FUZZY:=on}

  S_FILE=`echo $2                 |
          sed  "s/\.tar\.gz$//"   |
          sed  "s/\.tgz$//"       |
          sed  "s/\.tar\.bz2$//"`

  if erase $1 && call_wget $1 ; then
    FILE="$2"
  elif [ "$FUZZY" == "off" ] ; then
    activity_log  "lget"  "$MODULE"  "$VERSION"  "failed" "broken URL: $1"
    return 1
  elif erase $1 && call_wget $(dirname $1)/$S_FILE.tar.bz2 ; then
    FILE="$S_FILE.tar.bz2"
  elif erase $1 && call_wget $(dirname $1)/$S_FILE.tar.gz ; then
    FILE="$S_FILE.tar.gz"
  elif erase $1 && call_wget $(dirname $1)/$S_FILE.tgz ; then
    FILE="$S_FILE.tgz"
  else
    activity_log  "lget"  "$MODULE"  "$VERSION"  "failed" "broken URL: $1"
    return 1
  fi

  if testpack $(guess_filename $2) && mv $(guess_filename $2) $SOURCE_CACHE ; then
    verbose_msg "download of \"$1\" successfull"
  else
    rm -f $(guess_filename $2)
  fi
}


get_url() {
  if  [  -n  "$1"  ] ;  then
    if [ "${1:0:6}" == "cvs://" ] ; then
      # cvs urls
      CVS_THRESHOLD=${CVS_THRESHOLD:-10}
      if [ "$CVS_THRESHOLD" > 0 ] ; then
        if [ ! -f $SOURCE_CACHE/$2 ] ; then
	  get_cvs $1 $2
        elif [ "$(find $SOURCE_CACHE/$2 -amin +$CVS_THRESHOLD)" == "$SOURCE_CACHE/$2" ] ; then
	  get_cvs $1 $2
	else
	  verbose_msg "Skipping cvs update (less than $CVS_THRESHOLD mins old)"
	fi
      else
        get_cvs $1 $2
      fi
    elif [ "${1:0:6}" == "svn://" ] ; then
      # svn urls
      SVN_THRESHOLD=${SVN_THRESHOLD:-10}
      if [ "SVN_THRESHOLD" > 0 ] ; then
        if [ ! -f $SOURCE_CACHE/$2 ] ; then
	  get_svn $1 $2
	elif [ "$(find $SOURCE_CACHE/$2 -amin +$SVN_THRESHOLD)" == "$SOURCE_CACHE/$2" ] ; then
	  get_svn $1 $2
	else
	  verbose_msg "Skipping svn update (less than $SVN_THRESHOLD mins old)"
	fi
      else
        get_svn $1 $2
      fi
    elif [ "$1:0:7}" == "cpan://" ] ; then
      # no way, this cannot be tru
      #
      # and it isn't, but I thought this would be a cute, simple way of
      # fetching sources and possibly have 'CPAN' do all the work for us
      # thereby not opposing the normal perl module modules (like File-Tail)
      #
      :
    else
      # ordinary URL's handled by fuzzy_wget
      if  [  -n  "$BASE_URL"  ];  then
        URL=$BASE_URL/$2
      fi
      connect          &&
      if [ -n "$BASE_URL" ] ; then
        fuzzy_wget $BASE_URL/$2 $2
      elif ! fuzzy_wget $1 $2 ; then
        if [ -n "$LRESORT_URL" ] ; then
          fuzzy_wget $LRESORT_URL/$2 $2
        fi
      fi
    fi
  fi
}


lget_lock()  {
  echo $$ > /var/lock/lgetting.$1
}


lget_locked()  {
  if [ -f "/var/lock/lgetting.$1" ] &&
        ps `cat /var/lock/lgetting.$1` | grep  -q  "lget" ; then
    true
  else
    false
  fi
}


lget_unlock()  {
  rm -f /var/lock/lgetting.$1 &> /dev/null
}


download_module() { (
  if ! run_details $1 ; then
    exit 1
  fi

  MAX_SOURCES=${MAX_SOURCES:=100}

  # loop over all sources
  for (( N = 0 ; N < MAX_SOURCES ; N++ )) ; do
    # get the URL part
    eval SRC=\$$(echo SOURCE$N | sed s/SOURCE0/SOURCE/ )
    eval URLS=\${$(echo SOURCE${N}_URL | sed s/SOURCE0/SOURCE/ )[@]}

    # continue (to next) if empty once, break if empty tiwce
    if [ -z "$SRC" ] ; then
      if [ -z "$SECOND" ] ; then
        SECOND="yes"
        continue
      else
        break
      fi
    fi
    
    # silly that this exists:
    if [ "$CLEAR_CACHE" == "on" ] ; then
      verbose_msg "clearing source cache copy of \"$SRC\""
      rm -f `guess_filename  $SOURCE_CACHE/$SRC` 2>/dev/null
    fi

    # add source part if needed
    for URL in $URLS ; do
      if [ "${URL:((${#URL}-1)):1}" == "/" ] ; then
        URL=${URL}${SRC}
      fi

      # quit if we did get it
      if `guess_filename $SOURCE_CACHE/$SRC > /dev/null` ; then
        if [ ${URL:0:6} == "cvs://" ] ; then
	  verbose_msg "trying to download \"$URL\""
	  get_url $URL $SRC
	elif [ ${URL:0:6} = "svn://" ] ; then
	  verbose_msg "trying to download \"$URL\""
	  get_url $URL $SRC
	else
	  verbose_msg "Skipping download of \"$SRC\" for module \"$MODULE\" (in cache)"
	  continue 2
	fi
      else
        message  "${MESSAGE_COLOR}Downloading source file"  \
                 "${FILE_COLOR}${SRC}${DEFAULT_COLOR}"      \
                 "${MESSAGE_COLOR}for module"               \
                 "${MODULE_COLOR}${MODULE}${DEFAULT_COLOR}"
        verbose_msg "trying to download \"$URL\""
	get_url $URL $SRC
      fi
      
    done
  done

  return 0
  
) }


testpack () {
  FILENAME=`guess_filename $1` || FILENAME=`guess_filename $SOURCE_CACHE/$1`
  if [ -f $FILENAME ] ; then
    COMPRESSOR=`file -b $FILENAME | cut -d ' ' -f1`
    case $COMPRESSOR in
      bzip2)     bzip2 -tf  $FILENAME           >/dev/null 2>&1   ;;
      gzip)      gzip  -tf  $FILENAME           >/dev/null 2>&1   ;;
      compress*) gzip  -tf  $FILENAME           >/dev/null 2>&1   ;;
      Zip)       unzip -tq  $FILENAME           >/dev/null 2>&1   ;;
      RPM)       rpmunpack <$FILENAME | gzip -t >/dev/null 2>&1   ;;
      *)         true                                             ;;
    esac
  fi
}
