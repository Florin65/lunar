#!/bin/sh
############################################################
#                                                          #
# download.lunar - get sources from the net                #
#                                                          #
############################################################
# leach is part of the sorcery spell management utility    #
# Copyright 2001 by Kyle Sallee                            #
############################################################
#                                                          #
# this WAS the leach script of a source based Linux distro,#
# calls Sorcerer GNU/Linux, or SGL. SGL is no longer       #
# available with GPL license. Since this script was taken  #
# before licensing scheme change, no legal problems I      #
# guess.                                                   #
#                                                          #
# the code is re-written for Lunar. The previous Copyright #
# notices are kept; just in case some code is left :=)     #
# Kagan Kongar <kongar@tsrsb.org.tr>, 20020519             #
#                                                          #
# This secondly was lget mostly, and has been moved into   #
# a separate lunar functions file handling all the generic #
# downloading functionality for lunar                      #
#                                                          #
############################################################
#                                                          #
# Parts Copyrighted  Jason Johnston  2002 under GPLv2      #
#                                                          #
# Parts Copyrighted  Kagan Kongar  2002 under GPLv2        #
#                                                          #
# Parts Copyrighted  Auke Kok  2002 under GPLv2            #
#                                                          #
############################################################


use_cvs() {(
  run_details && if [[ $CVS_SERVER ]]; then

    if ! module_installed cvs ; then
      message "${PROBLEM_COLOR}Cannot fetch CVS sources without \"cvs\" installed!${DEFAULT_COLOR}"
      exit 1
    fi
    
    message  "${MESSAGE_COLOR}Downloading CVS module"                      \
             "${FILE_COLOR}${CVS_MODULE}${DEFAULT_COLOR}${MESSAGE_COLOR}"  \
             "for module ${MODULE_COLOR}${MODULE}${DEFAULT_COLOR}"
	     
    mk_source_dir
    cd $SOURCE_DIRECTORY

    export CVSROOT=$CVS_SERVER

    [ -f ~/.cvspass ] || touch ~/.cvspass

    if [[ $CVS_LOGIN ]]; then
      echo "$CVS_LOGIN" | cvs login
    fi

    if ! [[ $CVS_MODULE ]]; then
      CVS_MODULE=`echo $MODULE | sed s/-cvs//`
    fi

    if [[ -f $SOURCE_CACHE/$MODULE-$VERSION.tar.bz2 ]]; then
      verbose_msg "Extracting old CVS source tarball"
      tar xjf $SOURCE_CACHE/$MODULE-$VERSION.tar.bz2
    fi

    if [[ -d $CVS_MODULE/CVS ]]; then
      verbose_msg "cvs -qz3 up -PAd $CVS_MODULE"
      cvs -qz3 up -PAd $CVS_MODULE && GOT_CVS="yes" 
    elif ! [[ -d CVS ]]; then
      verbose_msg "cvs -qz3 co $CVS_MODULE"
      cvs -qz3 co $CVS_MODULE && GOT_CVS="yes"
    fi

    if [[ "$GOT_CVS" == "yes" ]]; then
      message "${MESSAGE_COLOR}Creating ${FILE_COLOR}$MODULE-$VERSION.tar.bz2${DEFAULT_COLOR}"
      tar cjf $SOURCE_CACHE/$MODULE-$VERSION.tar.bz2 $CVS_MODULE
    else
      activity_log "lget"  "$MODULE"  "$VERSION"  "failed" "Could not get $CVS_MODULE"
    fi

    cd $BUILD_DIRECTORY
    rm_source_dir

  fi
)}


erase()  {
  if  [  -z  "$PARTIAL"  ];  then
    rm  -f  $S_FILE.tar.gz  $S_FILE.tgz  $S_FILE.tar.bz2
  fi
}


call_wget()  {  
   [ -n "$http_proxy" ] && export http_proxy=$http_proxy
   [ -n  "$ftp_proxy" ] && export  ftp_proxy=$ftp_proxy
   [ -n   "$no_proxy" ] && export   no_proxy=$no_proxy

   verbose_msg "calling \"wget $CACHE $RATE $FTP_CONNECTION $RETRIES $PARTIAL $1\""
   wget $CACHE $RATE $FTP_CONNECTION $RETRIES $PARTIAL $1
}


fuzzy_wget()  {

  FTP_CONNECTION="--passive-ftp"
  [ "$FTP_ACTIVE"  == "on"   ] || 
  [ "$FTP_PASSIVE" == "off"  ] && 
  unset FTP_CONNECTION 

  PARTIAL="-c"
  [ "$CONTINUE" == "off" ] && unset PARTIAL

  CACHE="--cache=on"
  [ "$USE_CACHE" == "off" ] && CACHE="--cache=off"

  NUM_RETRY=${NUM_RETRY:=5}
  RETRIES="--tries=${NUM_RETRY}"

  [  -n  "$DOWNLOAD_RATE"  ] && RATE="--limit-rate=${DOWNLOAD_RATE}"

  FUZZY=${FUZZY:=on}

  S_URL=`echo  $URL              |
         sed  "s/\.tar\.gz$//"   |
         sed  "s/\.tgz$//"       |
         sed  "s/\.tar\.bz2$//"`

  S_FILE=`echo  $FILE             |
          sed  "s/\.tar\.gz$//"   |
          sed  "s/\.tgz$//"       |
          sed  "s/\.tar\.bz2$//"`

  if    erase  &&  call_wget  $URL;            then  FILE="$FILE"
  elif  [  "$FUZZY"  ==  "off"  ];             then
    activity_log  "lget"  "$MODULE"  "$VERSION"  "failed" "broken URL: $URL"
    return 1
  elif  erase  &&  call_wget  $S_URL.tar.bz2;  then  FILE="$S_FILE.tar.bz2"
  elif  erase  &&  call_wget  $S_URL.tar.gz;   then  FILE="$S_FILE.tar.gz"
  elif  erase  &&  call_wget  $S_URL.tgz;      then  FILE="$S_FILE.tgz"
  else
    activity_log  "lget"  "$MODULE"  "$VERSION"  "failed" "broken URL: $URL"
    false
  fi

}


disconnect()  {

  if    ps  -C disconnect  >  /dev/null
  then  return
  fi

  rm  -rf          /tmp/disconnect
  cat  <<  EOF  >  /tmp/disconnect
#!/bin/sh

while  ps  -A  |  grep  -q  "lget";  do  sleep  120;  done
poff
rm  /tmp/disconnect
EOF

chmod  a+x  /tmp/disconnect
            /tmp/disconnect  &

}


connect()  {

  if  !  ifconfig  |  grep  -q  "^eth"   &&
      !  ifconfig  |  grep  -q  "^wlan"  &&
      !  ifconfig  |  grep  -q  "^ppp"   &&
      !  ifconfig  |  grep  -q  "^tun";  then
    pon

    # Timeout in deciseconds to wait for Interface to come up.
    TIMEOUT=30

    until  ifconfig  |  grep  -q  eth   ||
           ifconfig  |  grep  -q  ppp   ||
           [  $TIMEOUT == 0  ]
    do
      sleep  10
      (( TIMEOUT-- ))
    done
    disconnect

  fi

}


get_url() {
  if  [  -n  "$1"  ] ;  then
    FILE=`basename  $1`
    if  [  -n  "$BASE_URL"  ];  then
      URL=$BASE_URL/$FILE
      connect          &&
      fuzzy_wget       &&
      testpack  $FILE  &&
      mv        $FILE  $SOURCE_CACHE &&
      verbose_msg "download of \"$1\" successfull"
    else
      URL=$1
      connect          &&
      fuzzy_wget       || {
        FILE=`basename  $1`
        [  -n  "$LRESORT_URL" ] && {
          URL=$LRESORT_URL/$FILE
          fuzzy_wget
        }
      } &&
      testpack  $FILE  &&
      mv        $FILE  $SOURCE_CACHE &&
      verbose_msg "download of \"$1\" successfull"
    fi
  fi
}


lget_lock()  {
  echo $$ > /var/lock/lgetting.$MODULE
}


lget_locked()  {
  if [ -f "/var/lock/lgetting.$MODULE" ] &&
        ps `cat /var/lock/lgetting.$MODULE` | grep  -q  "lget" ; then
    true
  else
    false
  fi
}


lget_unlock()  {
  rm -f /var/lock/lgetting.$MODULE &> /dev/null
}


download_module() { (

  MAX_SOURCES=${MAX_SOURCES:=100}

  # loop over all sources
  for (( N = 0 ; N < MAX_SOURCES ; N++ )) ; do
    # get the URL part
    eval  SRC=\$$(echo SOURCE$N          | sed s/SOURCE0/SOURCE/  )
    eval URLS=\${$(echo SOURCE${N}_URL    | sed s/SOURCE0/SOURCE/  )[@]}

    # continue (to next) if empty once, break if empty tiwce
    if [ -z "$SRC" ] ; then
      if [ -z "$SECOND" ] ; then
        SECOND="yes"
        continue
      else
        break
      fi
    fi
    
    # silly that this exists:
    if [ "$CLEAR_CACHE" == "on" ] ; then
      verbose_msg "clearing source cache copy of \"$SRC\""
      rm `guess_filename  $SOURCE_CACHE/$SRC` 2>/dev/null
    fi

    # classic lget shows this only once per source
    if ! `guess_filename $SOURCE_CACHE/$SRC > /dev/null` ; then
      message  "${MESSAGE_COLOR}Downloading source file"  \
               "${FILE_COLOR}${SRC}${DEFAULT_COLOR}"     \
               "${MESSAGE_COLOR}for module"               \
               "${MODULE_COLOR}${MODULE}${DEFAULT_COLOR}"
    else
      verbose_msg "skipping download of \"$SRC\" for module \"$MODULE\" (in cache)"
      continue
    fi

    # add source part if needed
    for URL in $URLS ; do
      if [ "${URL:((${#URL}-1)):1}" == "/" ] ; then
        URL=${URL}${SRC}
      fi

      # quit if we did get it
      if ! `guess_filename $SOURCE_CACHE/$SRC > /dev/null` ; then
        verbose_msg "trying to download \"$URL\""
        get_url $URL
      fi
      
    done
  done
  
) }


